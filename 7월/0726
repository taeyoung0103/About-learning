인덱싱과 슬라이싱을 이용한 배열의 원소 조회
배열 인덱싱(Indexing)
-> index
    배열내의 원소의 식별번호
    0부터 시작
-> indexing
    index를 이용해 원소 조회
    [] 표기법 사용

-> 구문
    ndarray[index]
    양수는 지정한 index의 값을 조회한다.
    음수는 뒤부터 조회한다.
        마지막 index가 -1
    2차원배열의 경우
        arr[행index, 열index]
        파이썬 리스트와 차이점 (list[행][열])
    N차원 배열의 경우
        arr[0축 index, 1축 index, ..., n축 index]

-> 팬시(fancy) 인덱싱
    여러개의 원소를 한번에 조회할 경우 리스트에 담아 전달한다.
    다차원 배열의 경우 각 축별로 list로 지정
    arr[[1,2,3,4,5]]
        1차원 배열(vector): 1,2,3,4,5 번 index의 원소들 한번에 조회
    arr[[0,3],[ 1,4]]
        [0,3] - 1번축 index list, [1,4] - 2번축 index list
        2차원 배열(matrix): [0,1], [3,4] 의 원소들 조회
        
        
# fancy indexing = 한번에 여러개값을 조회
# 2,5,7 
# a[2,5,7] #0축:2, 1축:5, 2축: 7
a[[2,5,7]] #리스트로 조회할 index들을 묶어준다.


a2 = np.arange(12).reshape(2,2,3)
a2.shape
a2
-> array([[[ 0,  1,  2],
        [ 3,  4,  5]],

       [[ 6,  7,  8],
        [ 9, 10, 11]]])
        

--------------------------------------------------------------

슬라이싱
  배열의 부분 집합을 하위배열로 조회 및 변경하는 방식
  ndarry[start : stop : step ]
      start : 시작 인덱스. 기본값 0
      stop : 끝 index. stop은 포함하지 않는다. 기본값 마지막 index
      step : 증감 간격. 기본값 1


a = np.arange(100)
a.shape
a
-> 0부터 99까지 차례로

a[10:50:2]     #10 ~ 50-1  step:+2
-> array([10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48])

a[:50:5] #0 ~ 50-1, step:+5,  
-> array([ 0,  5, 10, 15, 20, 25, 30, 35, 40, 45])

a[50::10] #50 ~ 끝,  step: 10
-> array([50, 60, 70, 80, 90])           a의 범위가 0~99이므로 결과가 이렇게 5개만 나온다.

a[10:1:-1] # 10 ~ 1+1: step: -1
# step(증감)을 음수 => 역순으로 조회(reverse)
-> array([10,  9,  8,  7,  6,  5,  4,  3,  2])



------------------------------------------------

다차원 배열 슬라이싱
    각 축에 slicing 문법 적용
    2차원의 경우
        arr [행 slicing, 열 slicing]
            arr[:3, :]
        , 로 행과 열을 구분한 다중 슬라이싱 사용
    다차원의 경우
        arr[0축 slicing, 1축 slicing, ..., n축 slicing]
    slicing과 indexing 문법은 같이 쓸 수 있다.
    모든 축에 index를 지정할 필요는 없다.

a = np.arange(48).reshape(6,8)
print(a.shape)
-> (6, 8) , 6행 8열
a
-> array([[ 0,  1,  2,  3,  4,  5,  6,  7],
       [ 8,  9, 10, 11, 12, 13, 14, 15],
       [16, 17, 18, 19, 20, 21, 22, 23],
       [24, 25, 26, 27, 28, 29, 30, 31],
       [32, 33, 34, 35, 36, 37, 38, 39],
       [40, 41, 42, 43, 44, 45, 46, 47]])


a[1:5, 1:6]  #0축: 1 ~ 4 step:+1, 1축: 1 ~ 5, step:+1
-> array([[ 9, 10, 11, 12, 13],
       [17, 18, 19, 20, 21],
       [25, 26, 27, 28, 29],
       [33, 34, 35, 36, 37]])

a[:, [0,2]] #모든 행(0축)에서 0, 2 열의 값(1축)만 조회
-> array([[ 0,  2],
       [ 8, 10],
       [16, 18],
       [24, 26],
       [32, 34],
       [40, 42]])
       
       
슬라이싱은 원본에 대한 View
    slicing한 결과는 새로운 배열을 생성하는 것이 아니라 기존 배열을 참조한다.
    slicing한 배열의 원소를 변경하면 원본 배열의 것도 바뀐다.
    배열.copy()
        배열을 복사한 새로운 배열 생성
        복사후 처리하면 원본이 바뀌지 않는다.


a
-> array([[ 0,  1,  2,  3,  4,  5,  6,  7],
       [ 8,  9, 10, 11, 12, 13, 14, 15],
       [16, 17, 18, 19, 20, 21, 22, 23],
       [24, 25, 26, 27, 28, 29, 30, 31],
       [32, 33, 34, 35, 36, 37, 38, 39],
       [40, 41, 42, 43, 44, 45, 46, 47]])
       

b = a[1:5, 1:6]
b
-> array([[ 9, 10, 11, 12, 13],
       [17, 18, 19, 20, 21],
       [25, 26, 27, 28, 29],
       [33, 34, 35, 36, 37]])
       
 b[0,0] = 9000 #원본배열(a)의 값도 같이 변경
 b
 -> array([[9000,   10,   11,   12,   13],
       [  17,   18,   19,   20,   21],
       [  25,   26,   27,   28,   29],
       [  33,   34,   35,   36,   37]])

a
-> array([[   0,    1,    2,    3,    4,    5,    6,    7],
       [   8, 9000,   10,   11,   12,   13,   14,   15],
       [  16,   17,   18,   19,   20,   21,   22,   23],
       [  24,   25,   26,   27,   28,   29,   30,   31],
       [  32,   33,   34,   35,   36,   37,   38,   39],
       [  40,   41,   42,   43,   44,   45,   46,   47]])
       -> a도 변한것을 확인할 수 있다.
       
c = a[1:5, 1:6].copy() #ndarray.copy() => 배열을 복사
c
-> array([[9000,   10,   11,   12,   13],
       [  17,   18,   19,   20,   21],
       [  25,   26,   27,   28,   29],
       [  33,   34,   35,   36,   37]])
       
c[0,0] = 9
c
-> array([[ 9, 10, 11, 12, 13],
       [17, 18, 19, 20, 21],
       [25, 26, 27, 28, 29],
       [33, 34, 35, 36, 37]])

a
-> array([[   0,    1,    2,    3,    4,    5,    6,    7],
       [   8, 9000,   10,   11,   12,   13,   14,   15],
       [  16,   17,   18,   19,   20,   21,   22,   23],
       [  24,   25,   26,   27,   28,   29,   30,   31],
       [  32,   33,   34,   35,   36,   37,   38,   39],
       [  40,   41,   42,   43,   44,   45,   46,   47]])


-> 복사를 하면 원본에 영향을 끼치지 않는다.
       
       
       
       
       
       







