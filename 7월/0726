인덱싱과 슬라이싱을 이용한 배열의 원소 조회
배열 인덱싱(Indexing)
-> index
    배열내의 원소의 식별번호
    0부터 시작
-> indexing
    index를 이용해 원소 조회
    [] 표기법 사용

-> 구문
    ndarray[index]
    양수는 지정한 index의 값을 조회한다.
    음수는 뒤부터 조회한다.
        마지막 index가 -1
    2차원배열의 경우
        arr[행index, 열index]
        파이썬 리스트와 차이점 (list[행][열])
    N차원 배열의 경우
        arr[0축 index, 1축 index, ..., n축 index]

-> 팬시(fancy) 인덱싱
    여러개의 원소를 한번에 조회할 경우 리스트에 담아 전달한다.
    다차원 배열의 경우 각 축별로 list로 지정
    arr[[1,2,3,4,5]]
        1차원 배열(vector): 1,2,3,4,5 번 index의 원소들 한번에 조회
    arr[[0,3],[ 1,4]]
        [0,3] - 1번축 index list, [1,4] - 2번축 index list
        2차원 배열(matrix): [0,1], [3,4] 의 원소들 조회
        
        
# fancy indexing = 한번에 여러개값을 조회
# 2,5,7 
# a[2,5,7] #0축:2, 1축:5, 2축: 7
a[[2,5,7]] #리스트로 조회할 index들을 묶어준다.


a2 = np.arange(12).reshape(2,2,3)
a2.shape
a2
-> array([[[ 0,  1,  2],
        [ 3,  4,  5]],

       [[ 6,  7,  8],
        [ 9, 10, 11]]])
        

--------------------------------------------------------------

슬라이싱
  배열의 부분 집합을 하위배열로 조회 및 변경하는 방식
  ndarry[start : stop : step ]
      start : 시작 인덱스. 기본값 0
      stop : 끝 index. stop은 포함하지 않는다. 기본값 마지막 index
      step : 증감 간격. 기본값 1


a = np.arange(100)
a.shape
a
-> 0부터 99까지 차례로

a[10:50:2]     #10 ~ 50-1  step:+2
-> array([10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48])

a[:50:5] #0 ~ 50-1, step:+5,  
-> array([ 0,  5, 10, 15, 20, 25, 30, 35, 40, 45])

a[50::10] #50 ~ 끝,  step: 10
-> array([50, 60, 70, 80, 90])           a의 범위가 0~99이므로 결과가 이렇게 5개만 나온다.

a[10:1:-1] # 10 ~ 1+1: step: -1
# step(증감)을 음수 => 역순으로 조회(reverse)
-> array([10,  9,  8,  7,  6,  5,  4,  3,  2])



------------------------------------------------

다차원 배열 슬라이싱
    각 축에 slicing 문법 적용
    2차원의 경우
        arr [행 slicing, 열 slicing]
            arr[:3, :]
        , 로 행과 열을 구분한 다중 슬라이싱 사용
    다차원의 경우
        arr[0축 slicing, 1축 slicing, ..., n축 slicing]
    slicing과 indexing 문법은 같이 쓸 수 있다.
    모든 축에 index를 지정할 필요는 없다.

a = np.arange(48).reshape(6,8)
print(a.shape)
-> (6, 8) , 6행 8열
a
-> array([[ 0,  1,  2,  3,  4,  5,  6,  7],
       [ 8,  9, 10, 11, 12, 13, 14, 15],
       [16, 17, 18, 19, 20, 21, 22, 23],
       [24, 25, 26, 27, 28, 29, 30, 31],
       [32, 33, 34, 35, 36, 37, 38, 39],
       [40, 41, 42, 43, 44, 45, 46, 47]])


a[1:5, 1:6]  #0축: 1 ~ 4 step:+1, 1축: 1 ~ 5, step:+1
-> array([[ 9, 10, 11, 12, 13],
       [17, 18, 19, 20, 21],
       [25, 26, 27, 28, 29],
       [33, 34, 35, 36, 37]])

a[:, [0,2]] #모든 행(0축)에서 0, 2 열의 값(1축)만 조회
-> array([[ 0,  2],
       [ 8, 10],
       [16, 18],
       [24, 26],
       [32, 34],
       [40, 42]])
       
       
슬라이싱은 원본에 대한 View
    slicing한 결과는 새로운 배열을 생성하는 것이 아니라 기존 배열을 참조한다.
    slicing한 배열의 원소를 변경하면 원본 배열의 것도 바뀐다.
    배열.copy()
        배열을 복사한 새로운 배열 생성
        복사후 처리하면 원본이 바뀌지 않는다.


a
-> array([[ 0,  1,  2,  3,  4,  5,  6,  7],
       [ 8,  9, 10, 11, 12, 13, 14, 15],
       [16, 17, 18, 19, 20, 21, 22, 23],
       [24, 25, 26, 27, 28, 29, 30, 31],
       [32, 33, 34, 35, 36, 37, 38, 39],
       [40, 41, 42, 43, 44, 45, 46, 47]])
       

b = a[1:5, 1:6]
b
-> array([[ 9, 10, 11, 12, 13],
       [17, 18, 19, 20, 21],
       [25, 26, 27, 28, 29],
       [33, 34, 35, 36, 37]])
       
 b[0,0] = 9000 #원본배열(a)의 값도 같이 변경
 b
 -> array([[9000,   10,   11,   12,   13],
       [  17,   18,   19,   20,   21],
       [  25,   26,   27,   28,   29],
       [  33,   34,   35,   36,   37]])

a
-> array([[   0,    1,    2,    3,    4,    5,    6,    7],
       [   8, 9000,   10,   11,   12,   13,   14,   15],
       [  16,   17,   18,   19,   20,   21,   22,   23],
       [  24,   25,   26,   27,   28,   29,   30,   31],
       [  32,   33,   34,   35,   36,   37,   38,   39],
       [  40,   41,   42,   43,   44,   45,   46,   47]])
       -> a도 변한것을 확인할 수 있다.
       
c = a[1:5, 1:6].copy() #ndarray.copy() => 배열을 복사
c
-> array([[9000,   10,   11,   12,   13],
       [  17,   18,   19,   20,   21],
       [  25,   26,   27,   28,   29],
       [  33,   34,   35,   36,   37]])
       
c[0,0] = 9
c
-> array([[ 9, 10, 11, 12, 13],
       [17, 18, 19, 20, 21],
       [25, 26, 27, 28, 29],
       [33, 34, 35, 36, 37]])

a
-> array([[   0,    1,    2,    3,    4,    5,    6,    7],
       [   8, 9000,   10,   11,   12,   13,   14,   15],
       [  16,   17,   18,   19,   20,   21,   22,   23],
       [  24,   25,   26,   27,   28,   29,   30,   31],
       [  32,   33,   34,   35,   36,   37,   38,   39],
       [  40,   41,   42,   43,   44,   45,   46,   47]])


-> 복사를 하면 원본에 영향을 끼치지 않는다.
       
       
------------------------------------------------------

boolean indexing
    Index 연산자에 Boolean 배열을 넣으면 True인 index의 값만 조회 (False가 있는 index는 조회하지 않는다.)
    ndarray내의 원소 중에서 원하는 조건의 값들만 조회할 때 사용
       
a = np.array([10,203,300])
b = [True, False, True] #masking
a[b]
-> array([ 10, 300])

a >= 1
-> a[[False,  True,  True]]

a[a>=1] #배열 a의 원소 중 1이상인 값들만 조회 => 특정 조건을 만족하는 원소들만 조회할 때 boolean indexing을 사용
-> array([ 10, 203, 300])

b = np.random.randint(100, size=100)
b
-> 0부터 99까지 100개의 수가 랜덤으로 100개가 나타내진다.

b2 = b.reshape(2,50)
print(b2.shape)
b2
-> 랜덤으로 100개 1묶음으로 있던것이 50개씩 2묶음으로 재정의되어서 만들어진다. b2라는 이름으로

b2[b2 >= 50] # ND array 에 boolean indexing을 적용하면 True값들만 1차원 배열에 모아서 반환.
-> 예) array([76, 91, 77, 70, 99, 90, 94, 63, 78, 56, 64, 73, 81, 81, 84, 74, 63,
       61, 90, 84, 88, 58, 77, 91, 89, 77, 78, 69, 82, 62, 70, 77, 74, 91,
       53, 79, 67, 92, 82, 52, 52, 86, 77, 94, 93, 60])
       
       
# 50 ~ 70 사이의 정수?
# 넘파이 논리연산자의 경우 파이썬의 and, or 는 사용할 수 없다.
# and: &, or: |, not: ~
# 피연산자는 반드시 ( ) 로 묶어 줘야 한다.

b[(b>=50) & (b<=70)]       
-> 50이상 70이하 둘다 만족하는 함수

b[~(b>50)] #not
-> 50보다 크지 않은 수를 뽑는 함수

--------------------------------------------------------

np.where()
    np.where(boolean 배열) - True인 index를 반환
    boolean연산과 같이쓰면 특정 조건을 만족하는 원소의 index조회됨.
    np.where(booean 배열, True를 대체할 값, False를 대체할 값)
        True와 False를 다른 값으로 변경한다.
        
l = [True, False, True]
l = np.array(l)
np.where(l) #리스트에서 True 값들의 index들을 반환(반환타입: Tuple)
-> (array([0, 2], dtype=int64),)

np.where(l, '참', '거짓') #True->'참', False->'거짓'
-> array(['참', '거짓', '참'], dtype='<U2')

np.where(l, '참', l) # True->'참', False->원래값
-> array(['참', 'False', '참'], dtype='<U5')

# b[b >= 50] #b의 원소중 50이상인 **값들**조회
np.where(b>=50) #b의 원소중 50이상인 값들의 **index**조회
-> 값이 아닌, 그 값의 index값이 출력된다.

np.where(b>=50, '50이상','50미만')
-> array(['50미만', '50미만', '50이상', '50이상', '50미만', '50이상', '50미만', '50미만'], dtype='<U4') 이런식으로 나타나진다.

# 70이상인 값들은 모두 70으로 변환, 70미만은 그대로 유지
np.where(b>=70, 70, b)
-> array([12, 27, 70, 70, 46, 70, 32, 17, 30, 70, 70, 70, 70, 43, 63, 32, 70])

c = np.arange(12).reshape(3,4)
c
-> array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])


np.where(c>5)
#반환: tuple
#(0축의 index 배열, 1축의 index 배열)
# (1,2), (1,3), (2,0), (2,1), (2,2), (2,3)
-> (array([1, 1, 2, 2, 2, 2], dtype=int64),
    array([2, 3, 0, 1, 2, 3], dtype=int64))
    -> 세로로 읽으면 된다. 첫번째부터 각각 (1,2), (1,3), (2,0), (2,1), (2,2), (2,3) 이렇게 의미한다.
    
----------------------------------------------

기타
    np.any(boolean 배열)
        배열에 True가 하나라도 있으면 True 반환
    np.all(boolean 배열)
        배열의 모든 원소가 True이면 True 반환

np.any(b>=99)  # 배열 b에 99이상인 값이 하나라도 있는지??
-> True

np.all(b>=90)  # 배열 b의 모든 원소들이 90 이상인가??
-> False

np.all(b>=0)
-> True

-----------------------------------------------

정렬
    np.sort(arr):
        매개변수로 전달한 배열을 정려한 새로운 배열을 반환한다.
        arr을 정렬
    ndarray.sort()
        ndarray 객체 자체를 정렬
    np.argsort(arr): 정렬 후 index를 반환


x = np.array([4, 1, 6, 9, 2])
x
-> array([4, 1, 6, 9, 2])

y = np.sort(x)  # x를 정렬한 원소들을 가지는 새로운 배열을 반환
y
-> array([1, 2, 4, 6, 9])

x.sort()  #배열 x(원본) 자체를 정렬
x
-> array([1, 2, 4, 6, 9])

z = np.array([4, 1, 6, 9, 2])
# 내림차순 정렬 -> slicing 이용
np.sort(z)[::-1]
-> array([9, 6, 4, 2, 1])
= -np.sort(-z)
       
a = np.array([0.1, 0.7, 0.4])
# 오름차순 정렬했을때 먼저오는 index를 알려줌
# 0, 2, 1


# 다차원 배열 정렬
# np.sort(배열, axis=기준축) 기준축 생략시 마지막 축을 기준으로 정렬


L = [
    [1, 0, 5],
    [0, 10, 2],
    [8, 7, 6]
]
arr = np.array(L)


np.sort(arr, axis=0)
-> array([[ 0,  0,  2],
       [ 1,  7,  5],
       [ 8, 10,  6]])
       
np.sort(arr, axis=1)
-> array([[ 0,  1,  5],
       [ 0,  2, 10],
       [ 6,  7,  8]])




