------------------------------------------------------------------------------

linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)
- 시작과 끝을 균등하게 나눈 값들을 가지는 배열을 생성
-> API
-> start : 시작값
-> stop : 종료값
-> num : 나눌 개수. 기본-50, 양수 여야한다.
-> endpoint : stop을 포함시킬 것인지 여부. 기본 True
-> retstep : 생성된 배열 샘플과 함께 간격(step)도 리턴할지 여부. True일경우 간격도 리턴(sample, step) => 튜플로 받는다.
-> dtype : 데이터 타입

a1 = np.linspace(1,100) # 1<= num <=100  50개 균등하게 나눈 값
a1
-> 1, 3.02, 5.04 ~~ 95.95, 97.97, 100 이렇게 50개가 나온다.

a2 = np.linspace(1,100, endpoint=False)
a2
-> endpoint인 100이 나눠지는 50개에서 제외되므로 값도 위에 a1과 달라진다.
-> 1, 2.98, 4.96 ~~ 96.04, 98.02 이렇게 50개가 나온다.

_______________________________________________________-

eye(N, M=None, k=0, dtype=<class 'float'>) / identity(N)
-> 항등행렬 생성 단위 행렬 생성
-> N : 행수
-> M : 컬럼수
-> k : 대각선이 시작할 index (첫행의 index를 지정한다. ) 기본값 : 0
-> API
-> -> 대각행렬
-> -> 행과 열이 같은 위치를 대각(diagnonal) 이라고 하며 그 대각에만 값이 있고 비대각은 0으로 채워진 행렬.
-> -> 항등행렬/단위행렬
-> -> 대각의 값이 1인 정방행렬로  𝐸 나  𝐼  로 표현한다.
-> -> 단위행렬은 행렬에서 곱셈의 항등원이다
-> -> 행렬곱셈(내적)에대해서 교환법칙이 성립한다.
-> -> 𝐴⋅𝐸=𝐴


a1 = np.eye(5)  # (5,5) shape의 항등행렬
print(a1.shape)
a1
-> array([[1., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.]])
       
np.eye(5, 9, k=5) #k=대각의 시작 index
 -> array([[0., 0., 0., 0., 0., 1., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 1., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 1.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0.]])
       
       
np.identity(3) #(3,3) 단위행렬    
-> array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
       

---------------------------------------------------

난수를 원소로 하는 ndarray 생성
-> numpy의 서브패키지인 random 패키지에서 제공하는 함수들
-> np.random.seed(정수) : 시드값 설정

np.random.seed(시드값)
-> 난수 발생 알고리즘이 사용할 시작값(시드값)을 설정
-> 시드값을 설정하면 항상 일정한 순서의 난수(random value)가 발생한다.
-> -> 랜덤함수는 특정숫자부터 시작하는 일렬의 수열을 만들어 값을 제공하는 함수이다.
    시작 숫자는 실행할때 마다 바뀌므로 다른 값들이 나오는데 시드값은 시작값을 고정시키면 항상 시작 값이 같으므로 같은 값들이 순서대로 제공된다.
    매번 실행할때 마다 같은 순서의 임의의 값이(난수) 나오도록 할때 시드값을 설정한다.
       
---------------------------------------------------------

np.random.rand(axis0[, axis1, axis2, ...])
-> API
-> 0~1사이의 실수를 리턴
-> 축의 크기는 순서대로 나열한다.
       
a = np.random.rand()  #0<= 실수 <1 
a       
-> 0에서 1사이의 수가 무작위로 나온다.       
       
b = np.random.rand(5)  # 0축 size->5
print(b.shape)
-> (5, )
b
-> 가로로 5개 값이 펼쳐지고, 그냥 random이므로 기본값인 0~1에서의 값이 설정되며, 무작위로 나온다.

c = np.random.rand(5,2,3)  # shape: (5,2,3)
print(c.shape)
-> (5,2,3)
c
-> array([[[0.64589411, 0.43758721, 0.891773  ],
        [0.96366276, 0.38344152, 0.79172504]],

       [[0.52889492, 0.56804456, 0.92559664],
        [0.07103606, 0.0871293 , 0.0202184 ]],

       [[0.83261985, 0.77815675, 0.87001215],
        [0.97861834, 0.79915856, 0.46147936]],

       [[0.78052918, 0.11827443, 0.63992102],
        [0.14335329, 0.94466892, 0.52184832]],

       [[0.41466194, 0.26455561, 0.77423369],
        [0.45615033, 0.56843395, 0.0187898 ]]])
        
        이런식으로 2행 3열, 5묶음으로 나온다.
        
a2 = np.random.normal(size=(5,4,4,4)) #size: shape을 튜플/리스트로 설정
a2
-> 총 5*4*4*4= 320 개의 값이 무작위로 나온다.

# 80 ~ 120 사이의 실수: 평균-100, 표준편차-10
a = np.random.normal(loc=100, scale=10, size=(5,5))
a
-> loc=평균, scale=표준편차, size=개수
       
------------------------------------------------------

np.random.randint(low, high=None, size=None, dtype='l')
임의의 정수를 가지는 배열
-> API
-> low ~ high 사이의 정수 리턴. high는 포함안됨
-> high 생략시 0 ~ low 사이 정수 리턴. low는 포함안됨
-> size : 배열의 크기. 다차원은 튜플로 지정 기본 1개
-> dtype : 원소의 타입


# 1 ~ 10 사이의 정수 난수
np.random.randint(1,11, size=(3,4))
-> array([[ 8,  4,  4,  1],
       [ 1, 10,  5,  5],
       [ 6,  9,  9,  1]])

# 0 ~ 100
np.random.randint(101, size=(3,4)) # 시작이 0일 경우는 생략
-> array([[30, 19,  4, 20],
       [74, 67, 86, 60],
       [93, 41, 40, 60]])
       
-----------------------------------------------------------------

np.random.choice(a, size=None, replace=True, p=None)
-> API
-> 샘플링 메소드
-> a : 샘플링대상. 1차원 배열 또는 정수 (정수일 경우 0 ~ 정수, 정수 불포함)
-> size : 샘플 개수
-> replace : True-복원추출(기본), False-비복원추출
-> p: 샘플링할 대상 값들이 추출될 확률 지정한 배열

a = np.arange(1,1000)
print(a.shape)
a
-> a는 1부터 1000까지의 모든 수를 가진 것

b= np.random.choice(a, size=10) # 배열 a의 원소(값)들 중 임의의 10개를 추출
print(b.shape)
b
-> 배열 a의 원소(값)들 중 임의의 10개를 추출

d = np.random.choice([True, False], size=10)#, replace=False)
d
-> array([False,  True, False,  True, False,  True, False,  True, False, False])


np.random.choice([True, False], size=10, p=[0.1, 0.9])  #True:10%확률, False:90%

---------------------------------------------------------

배열의 값 섞기
-> np.random.shuffle(배열)
-> -> 원본을 섞는다.
-> np.random.permutation(배열)
-> -> 원본을 섞은 카피배열을 반환
-> 다차원 배열의 경우는 0번 축을 기준으로 섞는다.

np.random.permutation(a)
-> 예) array([0, 6, 2, 7, 1, 3, 5, 4, 9, 8]) 이런식으로 나온다.

np.random.shuffle(a)
-> 무작위로 섞는다는 의미



























